# ğŸ§± Backend Boilerplate Repository (Node.js + TypeScript)

This repository provides a **work-ready backend boilerplate** for building scalable, secure, and maintainable RESTful APIs using **Node.js**, **TypeScript**, **Express**, **Objection.js/Knex**, and **PostgreSQL**.  
It also includes integrated **Swagger API documentation**, **Cucumber.js + Axios + Chai** test automation, **Docker support**, and **Winston-based logging**.

---

## ğŸš€ Quickstart

```bash
npm install
npm run dev
```

Now open in browser:

> http://localhost:5001/sample/0/check/randomNumber  

âœ… You should see a random number response as a health check.

---

### Or run each step manually:

1. **Transpile TypeScript**
   ```bash
   tsc
   ```

2. **Run ESLint**
   ```bash
   npm run lint
   ```

3. **Run the built app**
   ```bash
   node build/app.js
   ```

---

## ğŸ§­ Routes

| Endpoint | Description |
|-----------|-------------|
| `/` | Healthcheck |
| `/check/randomNumber` | Returns a random number (sample route) |
| `/api-docs` | Swagger UI Documentation |

Example:
> http://localhost:5001/check/randomNumber  
> http://localhost:5001/api-docs  

---

## âš™ï¸ Technologies Used

- **Node.js + TypeScript** â€” core backend framework
- **Express.js** â€” API routing and middleware
- **Objection.js + Knex** â€” ORM and SQL query builder
- **PostgreSQL** â€” database
- **Winston** â€” structured logging
- **Helmet, CORS, Rate Limiter** â€” security middlewares
- **Swagger-jsdoc + swagger-ui-express** â€” API documentation
- **Cucumber.js + Axios + Chai** â€” BDD API testing
- **Docker + Docker Compose** â€” containerized setup
- **ESLint + Prettier** â€” code style and linting

---

## ğŸ—ï¸ Folder Structure

```
src/
â”œâ”€â”€ app.ts               # Express app initialization
â”œâ”€â”€ index.ts             # Application entry point
â”œâ”€â”€ config/              # Environment variables, DB, and app configs
â”‚   â”œâ”€â”€ config.ts
â”‚   â””â”€â”€ db.ts
â”œâ”€â”€ controllers/         # Business logic handlers
â”œâ”€â”€ middlewares/         # Auth, rate limiting, validation, etc.
â”œâ”€â”€ models/              # Objection.js models
â”‚   â”œâ”€â”€ BaseModel.ts
â”‚   â””â”€â”€ UserModel.ts
â”œâ”€â”€ routes/              # Express route definitions
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ utils/               # Logger, helper functions
â”‚   â”œâ”€â”€ logger.ts
â”‚   â””â”€â”€ response.ts
â””â”€â”€ tests/               # Test suite (Cucumber + Chai + Axios)
    â”œâ”€â”€ features/
    â”œâ”€â”€ steps/
    â”œâ”€â”€ support/
    â””â”€â”€ data/
```

---

## ğŸ§ª Testing (Cucumber + Axios + Chai)

The project uses **Cucumber.js** for BDD-style API testing, **Axios** for HTTP calls, and **Chai** for assertions.

### ğŸ§  Folder Structure for Tests

```
tests/
â”œâ”€â”€ features/           # Cucumber feature files (.feature)
â”œâ”€â”€ steps/              # Step definitions (.ts)
â”œâ”€â”€ support/            # Hooks, environment setup, reusable config
â””â”€â”€ data/               # Sample payloads, JSON files
```

### ğŸ§© How to Create Test Scenarios

1. Create a new feature file under `tests/features`  
   Example: `tests/features/user.feature`
   ```gherkin
   Feature: User API

     Scenario: Fetch user details by ID
       Given I have a valid user ID
       When I send a GET request to "/users/1"
       Then the response status should be 200
       And the response body should contain "name"
   ```

2. Create step definitions under `tests/steps/user.steps.ts`
   ```ts
   import { Given, When, Then } from "@cucumber/cucumber";
   import axios from "axios";
   import { expect } from "chai";
   import { BASE_URL } from "../support/env";

   let response: any;

   Given("I have a valid user ID", function () {
     this.userId = 1;
   });

   When("I send a GET request to {string}", async function (endpoint: string) {
     response = await axios.get(`${BASE_URL}${endpoint}`);
   });

   Then("the response status should be {int}", function (statusCode: number) {
     expect(response.status).to.equal(statusCode);
   });

   Then("the response body should contain {string}", function (key: string) {
     expect(response.data).to.have.property(key);
   });
   ```

3. Run your tests:
   ```bash
   npm run test
   ```

4. Run a specific feature file:
   ```bash
   npx cucumber-js tests/features/user.feature
   ```

5. Run tests with tags:
   Add tags in feature file:
   ```gherkin
   @smoke
   Scenario: Fetch user details
   ```
   Run using:
   ```bash
   npx cucumber-js --tags "@smoke"
   ```

### ğŸ§± Script Configuration in `package.json`
```json
"scripts": {
  "test": "cucumber-js --require-module ts-node/register --require tests/steps --require tests/support --format progress"
}
```

### ğŸ§¾ Assertion Tips

- Use `chai.expect` for readable assertions.
- Keep each `Scenario` independent and small.
- Prefer environment variables for test base URLs and credentials.

---

## ğŸ“œ Swagger API Documentation

Access Swagger UI at: **http://localhost:5001/api-docs**

Swagger annotations are written using **OpenAPI JSDoc** in route files.

Example:
```js
/**
 * @openapi
 * /auth/login:
 *   post:
 *     tags:
 *       - Auth
 *     summary: Login API
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             properties:
 *               username:
 *                 type: string
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login successful
 */
```

---

## ğŸ§° Logger (Winston)

Logs all requests and errors with timestamps to `/logs/` folder.

Example configuration (`src/utils/logger.ts`):
```ts
import { createLogger, format, transports } from "winston";

export const logger = createLogger({
  level: "info",
  format: format.combine(format.timestamp(), format.json()),
  transports: [
    new transports.File({ filename: "logs/error.log", level: "error" }),
    new transports.File({ filename: "logs/combined.log" }),
  ],
});
```

---

## ğŸ³ Docker Setup

Run the app with PostgreSQL inside containers:

```bash
docker-compose up --build
```

**docker-compose.yml**
```yaml
version: "3.8"

services:
    boilerplate:
        container_name: boilerplate
        image: boilerplate
        build:
            context: .
            dockerfile: Dockerfile
        env_file:
            - .env
        ports:
            - "5100:5100"
        volumes:
            - ./logs:/usr/src/app/boilerplate/logs
        deploy:
            resources:
                limits:
                    cpus: "1"
                    memory: 4G
            restart_policy:
                condition: on-failure
```

---

## ğŸ” Encryption & Decryption Middleware

This boilerplate includes middleware for **AES-256-GCM encryption & decryption**, controlled via:

```
X-API-Encrypt: true | false
```

(Default = `true`)

### ğŸ“Œ Usage

```ts
app.use(
  `${routeURL}/dashboard`,
  decryptionMiddleware,
  dashBoardRouter,
  encryptionMiddleware
);
```

### Handles:
- Body decryption â†’ `req.body.data`
- Query param decryption â†’ `req.query.data`
- Response encryption â†’ `res.locals.apiResponse.data`

### Encrypted Request Format

```json
{
  "data": "iv:encryptedText:authTag"
}
```

### Encrypted Response Format

```json
{
  "status": 200,
  "error": false,
  "data": "iv:encryptedText:authTag"
}
```

### Controller Output Format

```ts
res.locals.apiResponse = {
  status: 200,
  error: false,
  data: { ... }
};
```

Middleware encrypts automatically.
